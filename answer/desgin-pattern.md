## 设计模式



### 主要参考

- <https://github.com/iluwatar/java-design-patterns>
- <https://github.com/youlookwhat/DesignPattern>



###设计模式

设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。(百度百科)

通过这些设计模式，能够帮助设计者更好地完成系统设计。

### 单例模式

- <http://www.hollischuang.com/archives/1373>

- <https://blog.csdn.net/dmk877/article/details/50311791>


单例模式主要是为了避免因为创建了多个实例造成资源的浪费，且多个实例由于多次调用容易导致结果出现错误，而使用单例模式能够保证整个应用中有且只有一个实例。

> 静态数据的生命周期是很长的，如果将其全部设成静态的，那将是对内存的极大损耗

操作：

1. 私有化该类的构造函数：不允许其他程序用new对象。
2. 通过new在本类中创建一个本类对象：在该类中创建对象。
3. 定义一个公有的方法，将在该类中所创建的对象返回：对外提供一个可以让其他程序获取该对象的方法。



单例的5种写法：

- 饿汉式：在类加载的时候就实例化了。

- 懒汉式：线程不安全（java并发编程的艺术有详解）
  - synchronized
  - volatile：禁止重排序

- 双重校验锁：

- 静态内部类：

- 枚举：
  - 为啥枚举也能实现单例



Java 中有哪些单例类？

<https://www.hollischuang.com/archives/1383>

`java.lang.Runtime`

由于Java是单进程的，所以，在一个JVM中，Runtime的实例应该只有一个。所以应该使用单例来实现。



序列化可以破坏单例？



### 简单工厂模式

https://www.hollischuang.com/archives/1391

GOF（Gang of four）...四人帮

简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例

用一个单独的类来做创造实例的过程。

以“计算器”为例。简单工厂，就是直接传入一个运算符号，然后返回对应的操作对象。

参考《大话设计模式》

### 策略模式



> 定义算法家族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化，不会影响到使用算法的客户。



### 装饰模式

> 动态地给一个对象添加一些额外的职责、就增加功能来说，装饰模式比生成子类更加灵活。
>
> （感觉像是一层层封装。。）
>
> 装饰模式的有点：把类中的修饰功能从类中移除，这样可以简化原有的类。
>
> （有点儿像组合，把原来的类实例对象保存一份，然后再添加一些新的方法。）



### 代理模式



> 为其他对象提供一种代理，以控制对这个对象的访问。
>
> （感觉代理和装饰有点类似，不过代理是增强某个功能，而装饰是添加一些新的功能）



### 工厂方法模式

<https://www.hollischuang.com/archives/1401>



> 工厂方法和简单工厂的区别：简单工厂的有点在于工厂类中包含了必要的逻辑判断，根绝客户端的选择动态实例化相关的类。但是简单工厂破坏了开闭原则。
>
> 工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使得一个类的实例化延迟到其子类。



### 原型模式

> 用原型实例指定创建的对象，并且通过拷贝这些原型创建新的对象



### 模板方法



> 定义一个操作中的算法骨架，而将一些不步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤。
>
> 简单来说，模板方法模式就是把不变的行为移到父类，去除子类的重复代码。



### 外观模式



> 为子系统的一组接口提供一个一致的界面。
>
> 比如对于旧系统的维护，就可以为新系统开发一个外观类，



### 建造者模式



> 建一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
>
> 什么时候用到：主要用于创建一些复杂的对象，这些对象内部构建间的顺序通常是稳定的。



### 观察者模式



> 观察者模式又叫发布订阅模式。定义了一种一对多的依赖关系，让多个观察者对象同时监听某个主题对象，这个主题对象在发生改变的时候，会通知所有观察者，使他们能够自动更新自己。
>
> 某个主题对象可以用一个列表来保存订阅的对象。
>
> 缺点：



### 抽象工厂模式

> 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
>
> （反射+抽象工厂模式实现SPI？？？）



### 状态模式



> 当一个对象的内在状态变化时，允许改变其行为，
>
> 状态模式主要解决的是：当控制一个状态转化的条件过于复杂的时候，把状态变化的逻辑转移到表示不同状态的一系列类中，可以把复杂的逻辑简化。



### 适配器模式

> 将一个接口转化为希望的另外一个接口，使得原本不兼容的的一些类能够在一起工作。
>
> （感觉和外观模式比较类似。。）



### 备忘录模式

> 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以对该对象恢复到原先保存的状态。



### 组合模式

> 将对象组合成树形结构以表示部分-整体的结构



### 迭代器模式



> 提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。



### 单例模式

> 保证类只有一个实例，提供一个访问它的全局访问点。



### 桥接模式



### 命令模式

> 将请求封装成一个对象，从而可以用不同的请求对客户进行参数化。



### 职责连模式

> 使多个对象都有机会处理请求，从而避免请求发送者和接收者之间的紧耦合，将这个对象连成一条链，并沿着链传递请求，直到有对象处理请求。



### 中介者模式

> 用一个中介对象来封装一系列的对象的交互，中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互。



### 享元模式

> 运用共享技术，有效地支持大量细粒度的对象。



### 解释器模式



> 给定一个语言，定义文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。



### 访问者模式

>